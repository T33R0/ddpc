
import { glob } from 'glob';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Resolve relative to the script location (apps/web/scripts)
const WEB_ROOT = path.resolve(__dirname, '..');
const REPO_ROOT = path.resolve(WEB_ROOT, '../..');

const APP_DIR = path.join(WEB_ROOT, 'src/app');
const UI_DIR = path.join(REPO_ROOT, 'packages/ui/src');
const UI_PACKAGE_JSON = path.join(REPO_ROOT, 'packages/ui/package.json');
const OUTPUT_FILE = path.join(WEB_ROOT, 'src/lib/component-registry.ts');
const SQL_OUTPUT_FILE = path.join(WEB_ROOT, 'seed_structure.sql');

async function scanStructure() {
  console.log('Scanning application structure...');

  // Load UI exports
  const uiPkg = JSON.parse(fs.readFileSync(UI_PACKAGE_JSON, 'utf-8'));
  const exports = uiPkg.exports || {};
  const validExports = new Set(
    Object.keys(exports)
      .map(k => k.replace(/^\.\//, '')) // remove ./ prefix
      .filter(k => k !== '*') // ignore wildcard
  );

  console.log('Valid UI Exports:', Array.from(validExports));

  const pages = await glob('**/page.tsx', { cwd: APP_DIR });
  const components = await glob('**/*.tsx', { cwd: UI_DIR });

  const registry: string[] = [];
  const sqlStatements: string[] = [];

  // Truncate table first
  sqlStatements.push('TRUNCATE TABLE app_structure;');

  // Process Pages
  for (const pageFile of pages) {
    const routePath = '/' + path.dirname(pageFile)
      .replace(/\\/g, '/')
      .replace(/\(.*\)\//g, '') // remove route groups like (auth)
      .replace(/\/page$/, '');

    // Normalize path (handle root page)
    const normalizedPath = routePath === '/.' ? '/' : routePath;
    const name = normalizedPath === '/' ? 'Home' :
      normalizedPath.split('/').filter(Boolean).pop()?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Page';

    const id = generateUUID(normalizedPath + 'page');

    sqlStatements.push(`INSERT INTO app_structure (id, name, type, path, last_updated, metadata) VALUES ('${id}', '${name}', 'page', '${normalizedPath}', NOW(), '{}');`);
  }

  // Process Components
  for (const compFile of components) {
    // Skip internal files
    if (compFile.includes('index.ts') || compFile.includes('.stories.') || compFile.includes('.test.')) continue;

    const name = path.basename(compFile, '.tsx');
    const pascalName = toPascalCase(name);
    // Sanitize component name for registry key
    const safeName = name.replace(/[^a-zA-Z0-9]/g, '');

    // Check if exported
    if (!validExports.has(name)) {
      continue;
    }

    // Add to registry with lazy import
    const importPath = `@repo/ui/${name}`;

    // Registry entry
    // Cast m to any to avoid TS errors about missing properties
    registry.push(`  '${name}': lazy(() => import('${importPath}').then((m: any) => ({ default: m.${pascalName} || m.${safeName} || m.default }))),`);

    const id = generateUUID(name + 'component');
    sqlStatements.push(`INSERT INTO app_structure (id, name, type, path, last_updated, metadata) VALUES ('${id}', '${name}', 'component', '${importPath}', NOW(), '{"defaultProps": {}}');`);
  }

  // Generate Registry File
  const fileContent = `
// Auto-generated by scripts/scan-structure.ts
import { lazy, ComponentType, LazyExoticComponent } from 'react';

export const ComponentRegistry: Record<string, LazyExoticComponent<ComponentType<any>>> = {
${registry.join('\n')}
};
`;

  fs.writeFileSync(OUTPUT_FILE, fileContent);
  console.log(`Registry written to ${OUTPUT_FILE}`);

  // Generate SQL File
  fs.writeFileSync(SQL_OUTPUT_FILE, sqlStatements.join('\n'));
  console.log(`SQL Seed written to ${SQL_OUTPUT_FILE}`);
}

function toPascalCase(str: string): string {
  return str.replace(/(^\w|-\w)/g, (g) => g.replace('-', '').toUpperCase());
}

// Simple UUID generator for consistent IDs based on string (mock implementation)
function generateUUID(input: string): string {
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  const hex = Math.abs(hash).toString(16).padStart(8, '0');
  return `00000000-0000-0000-0000-${hex.padEnd(12, '0')}`;
}

scanStructure().catch(console.error);
